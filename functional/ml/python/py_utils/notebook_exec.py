# Notebook execution utilities

import time
from pathlib import Path
from IPython.display import display, FileLink
import nbformat
from nbconvert.preprocessors import ExecutePreprocessor, ClearOutputPreprocessor


def dict_to_code(mapping):
    """Convert input dict `mapping` to a string containing python code.
    Each key is the name of a variable and each value is
    the variable content. Each variable assignment is separated by
    a newline.
    Keys must be strings, and cannot start with a number (i.e. must be
    valid python identifiers). Values must be objects with a string
    representation (the result of repr(obj)) which is valid python code for
    re-creating the object.
    For examples, numbers, strings or list/tuple/dict
    of numbers and strings are allowed.
    Returns:
        A string containing the python code.
    """
    lines = ("{} = {}".format(key, repr(value))
             for key, value in mapping.items())
    return '\n'.join(lines)


def default_link_fn(path, step):
    prefix = 'Input Notebook: ' if step == 'input' else 'Output Notebook: '
    display(FileLink(str(path), result_html_prefix=prefix))

def run_notebook(notebook_path, out_path=None,
                 nb_suffix='-out', nb_kwargs=None, clear_output=True, hide_input=True,
                 insert_pos=1, timeout=3600, execute_kwargs=None,
                 preproc_kwargs=None, link_fn=default_link_fn,
                 logger=None):
    """Runs a notebook and saves the output in a new notebook.
    Executes a notebook, optionally passing "arguments" in a way roughly
    similar to passing arguments to a function.
    Notebook arguments are passed in a dictionary (`nb_kwargs`) which is
    converted to a string containing python code, then inserted in the notebook
    as a code cell. The code contains only assignments of variables which
    can be used to control the execution of a suitably written notebook. When
    calling a notebook, you need to know which arguments (variables) to pass.
    Differently from functions, no check on the input arguments is performed.
    The "notebook signature" is only informally declared in a conventional
    markdown cell at the beginning of the notebook.
    Arguments:
        notebook_path (path-like object): path of the notebook to be
            executed. Valid values are strings or pathlib.Path objects.
        nb_suffix (string): suffix to append to the file name of the executed
            notebook.
        nb_kwargs (dict or None): If not None, this dict is converted to a
            string of python assignments with keys representing variables
            names and values variables content. This string is inserted as
            code-cell in the notebook to be executed.
        insert_pos (int): position of insertion of the code-cell containing
            the input arguments. Default is 1 (i.e. second cell). With this
            default, the input notebook can define, in the first cell, default
            values of input arguments (used when the notebook is executed
            with no arguments or through the Notebook GUI).
        timeout (int): timeout in seconds after which the execution is aborted.
        execute_kwargs (dict): additional arguments passed to
            `ExecutePreprocessor`.
        out_path (path-like or None): folder where to save the output
            notebook. If None, saves the notebook in the same folder as
            the template. Valid values are strings or pathlib.Path objects.
        clear_output: whether to clear output cells before executing notebook
        hide_input (bool): whether to create a notebook with input cells
            hidden (useful to remind user that the auto-generated output
            is not meant to have the code edited.
        link_fn (function): Function to take path for notebook (as Path) and
            display a FileLink for convenience; this is helpful when notebook paths
            are given as absolute paths and needed to be made relative for links to
            work correctly (see `default_link_fn`)
        logger: Optional logging object to be used for displaying error messages
            (stdout used by default)
    """
    timestamp_cell = ("**Executed:** %s\n\n**Duration:** %d seconds.\n\n"
                      "**Autogenerated from:** [%s](%s)")
    if nb_kwargs is not None:
        header = '# Cell inserted during automated execution.'
        code = dict_to_code(nb_kwargs)
        code_cell = '\n'.join((header, code))

    notebook_path = Path(notebook_path)
    if not notebook_path.is_file():
        raise FileNotFoundError("Path '%s' not found." % notebook_path)

    if out_path is None:
        out_path = notebook_path.parent
    out_path = Path(out_path)
    if not out_path.exists():
        raise FileNotFoundError("Output path '%s' not found." % out_path)
    out_notebook_path = (out_path /
                         ('%s%s.ipynb' % (notebook_path.stem, nb_suffix)))

    if link_fn is not None:
        link_fn(notebook_path, 'input')

    if execute_kwargs is None:
        execute_kwargs = {}
    ep = ExecutePreprocessor(timeout=timeout, **execute_kwargs)
    nb = nbformat.read(str(notebook_path), as_version=4)

    if hide_input:
        nb["metadata"].update({"hide_input": True})

    if len(nb_kwargs) > 0:
        nb['cells'].insert(insert_pos, nbformat.v4.new_code_cell(code_cell))

    start_time = time.time()
    try:
        # Execute the notebook
        preproc_kwargs = preproc_kwargs if preproc_kwargs is not None else {'metadata': {'path': './'}}
        if clear_output:
            nb, preproc_kwargs = ClearOutputPreprocessor().preprocess(nb, preproc_kwargs)
        ep.preprocess(nb, preproc_kwargs)
    except:
        # Execution failed, print a message then raise.
        msg = 'Error executing the notebook "%s".\n\n' % notebook_path
        msg += 'See notebook "%s" for the traceback.' % out_notebook_path
        if logger is not None:
            logger.error(msg)
        else:
            print(msg)
        raise
    else:
        # On successful execution, add timestamping cell
        duration = time.time() - start_time
        timestamp_cell = timestamp_cell % (time.ctime(start_time), duration,
                                           notebook_path, out_notebook_path)
        nb['cells'].insert(0, nbformat.v4.new_markdown_cell(timestamp_cell))
    finally:
        # Save the notebook even when it raises an error
        nbformat.write(nb, str(out_notebook_path))
        if link_fn is not None:
            link_fn(out_notebook_path, step='output')
    return notebook_path, out_notebook_path
